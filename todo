
**Project Vision and Concepts**:

* **Polycore**: A root server that routes and filters all commands, acting as a stateless, zero-trust middleware and context processor. It does not evaluate or execute logic itself but inspects and coordinates requests across various runtime contexts.

* **Context-Bound Scripts**: Scripts exist in a flat, non-hierarchical structure. All bindings register at the root level. Polycore handles context dispatch, authorization, and communication via port-based config recognition.

* **Bindings (e.g., PyPolycol, NodePolycol)**: Each language-specific binding is a self-contained, configurable interface that exposes functionality according to a defined contract. Bindings must declare their metadata, trust level, and API surface.

* **Codename-Based Versioning**: Instead of traditional semver alone, PolyBuild uses semantic codenames to represent stability and support status:

  * `paramental` = stable, LTS-supported
  * `zephyr` = experimental, unstable
  * `obelisk` = legacy, unsupported

  Polycore enforces compatibility rules based on codename, not just numeric version.

* **Command Infrastructure**: All operations are modeled as commands (e.g., `ffi`, `telemetry`, `micro`, `edge`, `config`). These commands expose modular functionality to the Polycore server and can be versioned and extended.

* **Dev Mode vs Stable Mode**:

  * **Dev Mode** allows full experimental and legacy module use with no restrictions.
  * **Stable Mode** enforces strict codename boundaries and disallows unstable modules from contaminating production builds.

* **Checkpoints & Hooks**:

  * Checkpoints act like Git stashes but are PolyBuild-native: full context snapshots saved to disk, optionally integrated with pre- and post-script hooks.
  * Git is optional. The project may implement `.polychk` or similar formats to enable Git-free time travel and system recovery.

**Instructions**:

1. Create a detailed yet digestible summary of the project.
2. Emphasize how this system differs from traditional build systems and why it exists.
3. Include notes about the zero-trust middleware pattern, the binder registry model, and codename enforcement.
4. Be technically clear, but do not oversimplify.
5. Highlight that this is an early-stage, exploratory design and not a finalized spec.

Do not attempt to correct the architectural decisions; assume the creator wants these principles enforced.
Output your summary in well-organized sections: Overview, Key Concepts, Command System, Versioning Model, Development vs Production Modes, and Checkpoint Strategy.

This is the full project vision for PolyBuild to be shared with Claude.
